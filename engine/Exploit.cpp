#include "Exploit.h"
#include <algorithm>
#include <thread>

// Base Exploit class implementation
Exploit::Exploit(std::string name, std::string description, ExploitType type, int difficulty, double successProb)
    : name(name), description(description), type(type), difficulty(difficulty), successProbability(successProb), targetPort(0) {
}

bool Exploit::requiresService(std::string service) const {
    return targetService == service;
}

bool Exploit::requiresPort(int port) const {
    return targetPort == port;
}

void Exploit::addRequiredTool(std::string tool) {
    requiredTools.push_back(tool);
}

// BruteForceExploit implementation
BruteForceExploit::BruteForceExploit() 
    : Exploit("Brute Force Attack", "Attempt to guess user passwords", BRUTE_FORCE, 3, 0.4), maxAttempts(100) {
    
    // Add common passwords
    passwordList = {
        "password", "123456", "admin", "root", "user", "pass", "password123",
        "admin123", "root123", "user123", "test", "guest", "welcome",
        "changeme", "secret", "qwerty", "letmein", "monkey", "dragon"
    };
    
    // Add common usernames
    usernameList = {
        "admin", "root", "user", "administrator", "guest", "test", "demo",
        "operator", "manager", "support", "helpdesk", "service"
    };
}

bool BruteForceExploit::canExploit(Node& target) {
    // Can exploit if target has user accounts
    return !target.users.empty();
}

ExploitResult BruteForceExploit::execute(Node& target) {
    ExploitResult result;
    auto startTime = std::chrono::high_resolution_clock::now();
    
    result.message = "Attempting brute force attack on " + target.ip;
    
    // Simulate attack attempts
    int attempts = 0;
    bool success = false;
    std::string compromisedUser = "";
    
    for (const std::string& username : usernameList) {
        if (attempts >= maxAttempts) break;
        
        for (const std::string& password : passwordList) {
            if (attempts >= maxAttempts) break;
            
            attempts++;
            
            // Simulate realistic timing
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            
            if (target.authenticateUser(username, password)) {
                success = true;
                compromisedUser = username;
                result.usersCompromised.push_back(username);
                break;
            }
        }
        
        if (success) break;
    }
    
    auto endTime = std::chrono::high_resolution_clock::now();
    result.timeTaken = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    if (success) {
        result.success = true;
        result.accessLevel = USER_ACCESS;
        result.message = "Successfully compromised user: " + compromisedUser;
        
        // Mark target as exploited
        target.markCompromised();
    } else {
        result.success = false;
        result.accessLevel = NO_ACCESS;
        result.errorMessage = "Failed to guess any valid credentials after " + std::to_string(attempts) + " attempts";
    }
    
    return result;
}

void BruteForceExploit::addPassword(std::string password) {
    passwordList.push_back(password);
}

void BruteForceExploit::addUsername(std::string username) {
    usernameList.push_back(username);
}

void BruteForceExploit::setMaxAttempts(int attempts) {
    maxAttempts = attempts;
}

// ServiceExploit implementation
ServiceExploit::ServiceExploit(std::string service, std::string vulnType)
    : Exploit("Service Exploit", "Exploit service-specific vulnerabilities", SERVICE_EXPLOIT, 5, 0.6),
      vulnerabilityType(vulnType) {
    targetService = service;
    
    // Initialize service vulnerabilities
    serviceVulnerabilities["SSH"] = 0.3;
    serviceVulnerabilities["FTP"] = 0.7;
    serviceVulnerabilities["HTTP"] = 0.5;
    serviceVulnerabilities["HTTPS"] = 0.4;
    serviceVulnerabilities["RDP"] = 0.6;
    serviceVulnerabilities["SMB"] = 0.8;
    serviceVulnerabilities["Telnet"] = 0.9;
}

bool ServiceExploit::canExploit(Node& target) {
    // Check if target has the required service running
    for (const Service& service : target.services) {
        if (service.serviceName == targetService && service.isRunning) {
            return true;
        }
    }
    return false;
}

ExploitResult ServiceExploit::execute(Node& target) {
    ExploitResult result;
    auto startTime = std::chrono::high_resolution_clock::now();
    
    result.message = "Attempting " + vulnerabilityType + " exploit on " + targetService + " service";
    
    // Get vulnerability probability for this service
    double vulnProb = 0.5; // Default
    if (serviceVulnerabilities.find(targetService) != serviceVulnerabilities.end()) {
        vulnProb = serviceVulnerabilities[targetService];
    }
    
    // Simulate exploit attempt
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);
    
    bool success = dis(gen) < vulnProb;
    
    // Simulate realistic timing
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    
    auto endTime = std::chrono::high_resolution_clock::now();
    result.timeTaken = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    if (success) {
        result.success = true;
        result.accessLevel = USER_ACCESS;
        result.message = "Successfully exploited " + targetService + " service";
        
        // Add some files that might be accessed
        if (targetService == "FTP") {
            result.filesAccessed.push_back("/var/ftp/pub/");
            result.filesAccessed.push_back("/home/ftp/");
        } else if (targetService == "HTTP") {
            result.filesAccessed.push_back("/var/www/html/");
            result.filesAccessed.push_back("/etc/apache2/");
        }
        
        target.markCompromised();
    } else {
        result.success = false;
        result.accessLevel = NO_ACCESS;
        result.errorMessage = "Failed to exploit " + targetService + " service";
    }
    
    return result;
}

void ServiceExploit::addServiceVulnerability(std::string service, double probability) {
    serviceVulnerabilities[service] = probability;
}

// BufferOverflowExploit implementation
BufferOverflowExploit::BufferOverflowExploit()
    : Exploit("Buffer Overflow", "Exploit buffer overflow vulnerabilities", BUFFER_OVERFLOW, 8, 0.3),
      payload(std::string(1000, 'A')), bufferSize(1024) {
}

bool BufferOverflowExploit::canExploit(Node& target) {
    // Check if target has services that might be vulnerable to buffer overflow
    for (const Service& service : target.services) {
        if (service.serviceName == "FTP" || service.serviceName == "HTTP" || 
            service.serviceName == "SMTP" || service.serviceName == "POP3") {
            return true;
        }
    }
    return false;
}

ExploitResult BufferOverflowExploit::execute(Node& target) {
    ExploitResult result;
    auto startTime = std::chrono::high_resolution_clock::now();
    
    result.message = "Attempting buffer overflow exploit";
    
    // Simulate buffer overflow attempt
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);
    
    bool success = dis(gen) < successProbability;
    
    // Simulate realistic timing
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    
    auto endTime = std::chrono::high_resolution_clock::now();
    result.timeTaken = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    if (success) {
        result.success = true;
        result.accessLevel = ROOT_ACCESS;
        result.message = "Buffer overflow successful - gained root access";
        target.markCompromised();
    } else {
        result.success = false;
        result.accessLevel = NO_ACCESS;
        result.errorMessage = "Buffer overflow failed - service may be patched";
    }
    
    return result;
}

void BufferOverflowExploit::setPayload(std::string payload) {
    this->payload = payload;
}

void BufferOverflowExploit::setBufferSize(int size) {
    bufferSize = size;
}

// PrivilegeEscalationExploit implementation
PrivilegeEscalationExploit::PrivilegeEscalationExploit()
    : Exploit("Privilege Escalation", "Attempt to gain higher privileges", PRIVILEGE_ESCALATION, 7, 0.4) {
    
    escalationMethods = {
        "sudo exploit", "kernel exploit", "service misconfiguration",
        "weak file permissions", "environment variable manipulation"
    };
}

bool PrivilegeEscalationExploit::canExploit(Node& target) {
    // Can attempt privilege escalation if we have some access
    return target.isCompromised();
}

ExploitResult PrivilegeEscalationExploit::execute(Node& target) {
    ExploitResult result;
    auto startTime = std::chrono::high_resolution_clock::now();
    
    result.message = "Attempting privilege escalation";
    
    // Simulate privilege escalation attempt
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);
    
    bool success = dis(gen) < successProbability;
    
    // Simulate realistic timing
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    
    auto endTime = std::chrono::high_resolution_clock::now();
    result.timeTaken = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    if (success) {
        result.success = true;
        result.accessLevel = ROOT_ACCESS;
        result.message = "Privilege escalation successful - gained root access";
        
        // Access system files
        result.filesAccessed.push_back("/etc/passwd");
        result.filesAccessed.push_back("/etc/shadow");
        result.filesAccessed.push_back("/root/");
    } else {
        result.success = false;
        result.accessLevel = USER_ACCESS;
        result.errorMessage = "Privilege escalation failed";
    }
    
    return result;
}

void PrivilegeEscalationExploit::addEscalationMethod(std::string method) {
    escalationMethods.push_back(method);
}

// SQL Injection Exploit implementation
SQLInjectionExploit::SQLInjectionExploit()
    : Exploit("SQL Injection", "Exploit SQL injection vulnerabilities in web applications", SQL_INJECTION, 6, 0.5),
      targetParameter("id"), databaseType("MySQL") {
    
    // Common SQL injection payloads
    payloads = {
        "' OR '1'='1",
        "' OR 1=1--",
        "' UNION SELECT NULL--",
        "'; DROP TABLE users--",
        "' OR '1'='1' #",
        "admin'--",
        "1' OR '1' = '1' OR '1' = '1",
        "' UNION SELECT username,password FROM users--",
        "'; EXEC xp_cmdshell('dir')--",
        "' OR 1=1 LIMIT 1--"
    };
    
    targetService = "HTTP";
    targetPort = 80;
}

bool SQLInjectionExploit::canExploit(Node& target) {
    // Check if target has HTTP/HTTPS service
    for (const Service& service : target.services) {
        if ((service.serviceName == "HTTP" || service.serviceName == "HTTPS") && service.isRunning) {
            return true;
        }
    }
    return false;
}

ExploitResult SQLInjectionExploit::execute(Node& target) {
    ExploitResult result;
    auto startTime = std::chrono::high_resolution_clock::now();
    
    result.message = "Attempting SQL injection on " + targetParameter + " parameter";
    
    // Simulate SQL injection attempt
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);
    
    bool success = dis(gen) < successProbability;
    
    // Simulate realistic timing
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    
    auto endTime = std::chrono::high_resolution_clock::now();
    result.timeTaken = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    if (success) {
        result.success = true;
        result.accessLevel = USER_ACCESS;
        result.message = "Successfully exploited SQL injection vulnerability";
        
        // Add database files that might be accessed
        result.filesAccessed.push_back("/var/lib/mysql/");
        result.filesAccessed.push_back("/etc/mysql/");
        result.filesAccessed.push_back("database.sql");
        
        // Add some compromised users
        result.usersCompromised.push_back("admin");
        result.usersCompromised.push_back("user1");
        
        target.markCompromised();
    } else {
        result.success = false;
        result.accessLevel = NO_ACCESS;
        result.errorMessage = "SQL injection attempt failed - input validation detected";
    }
    
    return result;
}

void SQLInjectionExploit::addPayload(std::string payload) {
    payloads.push_back(payload);
}

void SQLInjectionExploit::setTargetParameter(std::string param) {
    targetParameter = param;
}

void SQLInjectionExploit::setDatabaseType(std::string dbType) {
    databaseType = dbType;
}

// XSS Exploit implementation
XSSExploit::XSSExploit()
    : Exploit("Cross-Site Scripting", "Exploit XSS vulnerabilities in web applications", XSS_EXPLOIT, 4, 0.6),
      targetParameter("search"), attackType("reflected") {
    
    // Common XSS payloads
    xssPayloads = {
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "javascript:alert('XSS')",
        "<svg onload=alert('XSS')>",
        "'><script>alert('XSS')</script>",
        "<iframe src=javascript:alert('XSS')>",
        "<body onload=alert('XSS')>",
        "<input onfocus=alert('XSS') autofocus>",
        "<details open ontoggle=alert('XSS')>",
        "<video><source onerror=alert('XSS')>"
    };
    
    targetService = "HTTP";
    targetPort = 80;
}

bool XSSExploit::canExploit(Node& target) {
    // Check if target has HTTP/HTTPS service
    for (const Service& service : target.services) {
        if ((service.serviceName == "HTTP" || service.serviceName == "HTTPS") && service.isRunning) {
            return true;
        }
    }
    return false;
}

ExploitResult XSSExploit::execute(Node& target) {
    ExploitResult result;
    auto startTime = std::chrono::high_resolution_clock::now();
    
    result.message = "Attempting " + attackType + " XSS attack on " + targetParameter + " parameter";
    
    // Simulate XSS attempt
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);
    
    bool success = dis(gen) < successProbability;
    
    // Simulate realistic timing
    std::this_thread::sleep_for(std::chrono::milliseconds(600));
    
    auto endTime = std::chrono::high_resolution_clock::now();
    result.timeTaken = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    if (success) {
        result.success = true;
        result.accessLevel = USER_ACCESS;
        result.message = "Successfully exploited " + attackType + " XSS vulnerability";
        
        // Add web files that might be accessed
        result.filesAccessed.push_back("/var/www/html/");
        result.filesAccessed.push_back("/tmp/");
        result.filesAccessed.push_back("session.txt");
        
        target.markCompromised();
    } else {
        result.success = false;
        result.accessLevel = NO_ACCESS;
        result.errorMessage = "XSS attack failed - input sanitization detected";
    }
    
    return result;
}

void XSSExploit::addXSSPayload(std::string payload) {
    xssPayloads.push_back(payload);
}

void XSSExploit::setTargetParameter(std::string param) {
    targetParameter = param;
}

void XSSExploit::setAttackType(std::string type) {
    attackType = type;
}

// CSRF Exploit implementation
CSRFExploit::CSRFExploit()
    : Exploit("Cross-Site Request Forgery", "Exploit CSRF vulnerabilities in web applications", CSRF_EXPLOIT, 5, 0.4),
      targetAction("/admin/change_password"), attackMethod("POST") {
    
    targetService = "HTTP";
    targetPort = 80;
}

bool CSRFExploit::canExploit(Node& target) {
    // Check if target has HTTP/HTTPS service
    for (const Service& service : target.services) {
        if ((service.serviceName == "HTTP" || service.serviceName == "HTTPS") && service.isRunning) {
            return true;
        }
    }
    return false;
}

ExploitResult CSRFExploit::execute(Node& target) {
    ExploitResult result;
    auto startTime = std::chrono::high_resolution_clock::now();
    
    result.message = "Attempting CSRF attack on " + targetAction;
    
    // Simulate CSRF attempt
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);
    
    bool success = dis(gen) < successProbability;
    
    // Simulate realistic timing
    std::this_thread::sleep_for(std::chrono::milliseconds(700));
    
    auto endTime = std::chrono::high_resolution_clock::now();
    result.timeTaken = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    if (success) {
        result.success = true;
        result.accessLevel = USER_ACCESS;
        result.message = "Successfully exploited CSRF vulnerability";
        
        // Add files that might be modified
        result.filesAccessed.push_back("/var/www/html/admin/");
        result.filesAccessed.push_back("/etc/passwd");
        result.filesAccessed.push_back("config.php");
        
        target.markCompromised();
    } else {
        result.success = false;
        result.accessLevel = NO_ACCESS;
        result.errorMessage = "CSRF attack failed - CSRF token protection detected";
    }
    
    return result;
}

void CSRFExploit::setTargetAction(std::string action) {
    targetAction = action;
}

void CSRFExploit::setCSRFToken(std::string token) {
    csrfToken = token;
}

void CSRFExploit::setAttackMethod(std::string method) {
    attackMethod = method;
}

// Path Traversal Exploit implementation
PathTraversalExploit::PathTraversalExploit()
    : Exploit("Path Traversal", "Exploit path traversal vulnerabilities", PATH_TRAVERSAL, 3, 0.7),
      targetFile("/etc/passwd") {
    
    // Common path traversal payloads
    traversalPayloads = {
        "../../../etc/passwd",
        "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
        "....//....//....//etc/passwd",
        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        "..%252f..%252f..%252fetc%252fpasswd",
        "..%c0%af..%c0%af..%c0%afetc%c0%afpasswd",
        "..%255c..%255c..%255cwindows%255csystem32%255cdrivers%255cetc%255chosts",
        "..%5c..%5c..%5cwindows%5csystem32%5cdrivers%5cetc%5chosts"
    };
    
    targetService = "HTTP";
    targetPort = 80;
}

bool PathTraversalExploit::canExploit(Node& target) {
    // Check if target has HTTP/FTP service
    for (const Service& service : target.services) {
        if ((service.serviceName == "HTTP" || service.serviceName == "FTP") && service.isRunning) {
            return true;
        }
    }
    return false;
}

ExploitResult PathTraversalExploit::execute(Node& target) {
    ExploitResult result;
    auto startTime = std::chrono::high_resolution_clock::now();
    
    result.message = "Attempting path traversal to access " + targetFile;
    
    // Simulate path traversal attempt
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);
    
    bool success = dis(gen) < successProbability;
    
    // Simulate realistic timing
    std::this_thread::sleep_for(std::chrono::milliseconds(400));
    
    auto endTime = std::chrono::high_resolution_clock::now();
    result.timeTaken = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    if (success) {
        result.success = true;
        result.accessLevel = USER_ACCESS;
        result.message = "Successfully exploited path traversal vulnerability";
        
        // Add files that might be accessed
        result.filesAccessed.push_back(targetFile);
        result.filesAccessed.push_back("/etc/shadow");
        result.filesAccessed.push_back("/etc/hosts");
        result.filesAccessed.push_back("/proc/version");
        
        target.markCompromised();
    } else {
        result.success = false;
        result.accessLevel = NO_ACCESS;
        result.errorMessage = "Path traversal failed - input validation detected";
    }
    
    return result;
}

void PathTraversalExploit::addTraversalPayload(std::string payload) {
    traversalPayloads.push_back(payload);
}

void PathTraversalExploit::setTargetFile(std::string file) {
    targetFile = file;
}

// Command Injection Exploit implementation
CommandInjectionExploit::CommandInjectionExploit()
    : Exploit("Command Injection", "Exploit command injection vulnerabilities", COMMAND_INJECTION, 7, 0.4),
      targetCommand("whoami"), injectionPoint("ping") {
    
    // Common command injection payloads
    injectionPayloads = {
        "; whoami",
        "| whoami",
        "& whoami",
        "&& whoami",
        "|| whoami",
        "; cat /etc/passwd",
        "| cat /etc/passwd",
        "& cat /etc/passwd",
        "; ls -la",
        "| ls -la"
    };
    
    targetService = "HTTP";
    targetPort = 80;
}

bool CommandInjectionExploit::canExploit(Node& target) {
    // Check if target has HTTP service
    for (const Service& service : target.services) {
        if (service.serviceName == "HTTP" && service.isRunning) {
            return true;
        }
    }
    return false;
}

ExploitResult CommandInjectionExploit::execute(Node& target) {
    ExploitResult result;
    auto startTime = std::chrono::high_resolution_clock::now();
    
    result.message = "Attempting command injection via " + injectionPoint + " parameter";
    
    // Simulate command injection attempt
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);
    
    bool success = dis(gen) < successProbability;
    
    // Simulate realistic timing
    std::this_thread::sleep_for(std::chrono::milliseconds(900));
    
    auto endTime = std::chrono::high_resolution_clock::now();
    result.timeTaken = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    if (success) {
        result.success = true;
        result.accessLevel = USER_ACCESS;
        result.message = "Successfully exploited command injection vulnerability";
        
        // Add files that might be accessed
        result.filesAccessed.push_back("/etc/passwd");
        result.filesAccessed.push_back("/etc/shadow");
        result.filesAccessed.push_back("/proc/version");
        result.filesAccessed.push_back("/home/");
        
        target.markCompromised();
    } else {
        result.success = false;
        result.accessLevel = NO_ACCESS;
        result.errorMessage = "Command injection failed - input validation detected";
    }
    
    return result;
}

void CommandInjectionExploit::addInjectionPayload(std::string payload) {
    injectionPayloads.push_back(payload);
}

void CommandInjectionExploit::setTargetCommand(std::string command) {
    targetCommand = command;
}

void CommandInjectionExploit::setInjectionPoint(std::string point) {
    injectionPoint = point;
}

// ExploitChain implementation
ExploitChain::ExploitChain(std::string name) : name(name), chainSuccessProbability(1.0) {
}

ExploitChain::~ExploitChain() {
    // Don't delete exploits as they're managed by ExploitDatabase
}

void ExploitChain::addExploit(Exploit* exploit) {
    exploits.push_back(exploit);
    // Recalculate chain success probability
    chainSuccessProbability *= exploit->getSuccessProbability();
}

ExploitResult ExploitChain::executeChain(Node& target) {
    ExploitResult result;
    result.message = "Executing exploit chain: " + name;
    
    for (Exploit* exploit : exploits) {
        if (!exploit->canExploit(target)) {
            result.success = false;
            result.errorMessage = "Exploit " + exploit->getName() + " cannot be executed on target";
            return result;
        }
        
        ExploitResult exploitResult = exploit->execute(target);
        if (!exploitResult.success) {
            result.success = false;
            result.errorMessage = "Chain failed at exploit: " + exploit->getName() + " - " + exploitResult.errorMessage;
            return result;
        }
        
        // Update result with successful exploit
        result.accessLevel = std::max(result.accessLevel, exploitResult.accessLevel);
        result.filesAccessed.insert(result.filesAccessed.end(), exploitResult.filesAccessed.begin(), exploitResult.filesAccessed.end());
        result.usersCompromised.insert(result.usersCompromised.end(), exploitResult.usersCompromised.begin(), exploitResult.usersCompromised.end());
        result.timeTaken += exploitResult.timeTaken;
    }
    
    result.success = true;
    result.message = "Exploit chain completed successfully";
    return result;
}

double ExploitChain::getChainSuccessProbability() const {
    return chainSuccessProbability;
}

// ExploitDatabase implementation
ExploitDatabase::ExploitDatabase() {
    loadDefaultExploits();
}

ExploitDatabase::~ExploitDatabase() {
    clearExploits();
}

void ExploitDatabase::addExploit(Exploit* exploit) {
    exploits.push_back(exploit);
    exploitsByType[exploit->getType()].push_back(exploit);
    exploitsByService[exploit->getTargetService()].push_back(exploit);
}

std::vector<Exploit*> ExploitDatabase::getExploitsForNode(Node& target) {
    std::vector<Exploit*> applicableExploits;
    
    for (Exploit* exploit : exploits) {
        if (exploit->canExploit(target)) {
            applicableExploits.push_back(exploit);
        }
    }
    
    return applicableExploits;
}

std::vector<Exploit*> ExploitDatabase::getExploitsForService(std::string service) {
    if (exploitsByService.find(service) != exploitsByService.end()) {
        return exploitsByService[service];
    }
    return std::vector<Exploit*>();
}

std::vector<Exploit*> ExploitDatabase::getExploitsByType(ExploitType type) {
    if (exploitsByType.find(type) != exploitsByType.end()) {
        return exploitsByType[type];
    }
    return std::vector<Exploit*>();
}

std::vector<Exploit*> ExploitDatabase::getAllExploits() const {
    return exploits;
}

Exploit* ExploitDatabase::findExploitByName(std::string name) {
    for (Exploit* exploit : exploits) {
        if (exploit->getName() == name) {
            return exploit;
        }
    }
    return nullptr;
}

void ExploitDatabase::loadDefaultExploits() {
    // Add brute force exploits
    addExploit(new BruteForceExploit());
    
    // Add service exploits
    addExploit(new ServiceExploit("SSH", "weak_configuration"));
    addExploit(new ServiceExploit("FTP", "anonymous_access"));
    addExploit(new ServiceExploit("HTTP", "directory_traversal"));
    addExploit(new ServiceExploit("RDP", "weak_authentication"));
    addExploit(new ServiceExploit("SMB", "null_session"));
    addExploit(new ServiceExploit("Telnet", "cleartext_authentication"));
    
    // Add buffer overflow exploits
    addExploit(new BufferOverflowExploit());
    
    // Add privilege escalation exploits
    addExploit(new PrivilegeEscalationExploit());
    
    // Add web application exploits
    addExploit(new SQLInjectionExploit());
    addExploit(new XSSExploit());
    addExploit(new CSRFExploit());
    addExploit(new PathTraversalExploit());
    addExploit(new CommandInjectionExploit());
}

void ExploitDatabase::clearExploits() {
    for (Exploit* exploit : exploits) {
        delete exploit;
    }
    exploits.clear();
    exploitsByType.clear();
    exploitsByService.clear();
}
