#include "Exploit.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <random>
#include <algorithm>

Exploit::Exploit() : id(0), successRate(0.0f), isActive(false), complexity(ExploitComplexity::LOW) {
}

Exploit::Exploit(int exploitId, const std::string& name, const std::string& description, 
                 ExploitType type, float successRate, ExploitComplexity complexity)
    : id(exploitId), name(name), description(description), type(type), 
      successRate(successRate), complexity(complexity), isActive(false) {
}

Exploit::~Exploit() {
}

int Exploit::getId() const {
    return id;
}

const std::string& Exploit::getName() const {
    return name;
}

const std::string& Exploit::getDescription() const {
    return description;
}

ExploitType Exploit::getType() const {
    return type;
}

float Exploit::getSuccessRate() const {
    return successRate;
}

ExploitComplexity Exploit::getComplexity() const {
    return complexity;
}

bool Exploit::isExploitActive() const {
    return isActive;
}

void Exploit::activate() {
    isActive = true;
    std::cout << "Exploit '" << name << "' activated." << std::endl;
}

void Exploit::deactivate() {
    isActive = false;
    std::cout << "Exploit '" << name << "' deactivated." << std::endl;
}

bool Exploit::execute(const std::string& target, const std::vector<std::string>& parameters) {
    if (!isActive) {
        std::cout << "Cannot execute inactive exploit." << std::endl;
        return false;
    }
    
    std::cout << "Executing exploit '" << name << "' on target: " << target << std::endl;
    
    // Simulate execution with success rate and complexity
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<float> dist(0.0f, 1.0f);
    
    float adjustedSuccessRate = successRate;
    switch (complexity) {
        case ExploitComplexity::LOW:
            adjustedSuccessRate *= 1.0f;
            break;
        case ExploitComplexity::MEDIUM:
            adjustedSuccessRate *= 0.8f;
            break;
        case ExploitComplexity::HIGH:
            adjustedSuccessRate *= 0.6f;
            break;
        case ExploitComplexity::CRITICAL:
            adjustedSuccessRate *= 0.4f;
            break;
    }
    
    bool success = dist(gen) <= adjustedSuccessRate;
    
    if (success) {
        std::cout << "Exploit execution successful!" << std::endl;
        executionHistory.push_back({target, true, "Success", parameters});
    } else {
        std::cout << "Exploit execution failed." << std::endl;
        executionHistory.push_back({target, false, "Failed", parameters});
    }
    
    return success;
}

const std::vector<ExploitExecutionRecord>& Exploit::getExecutionHistory() const {
    return executionHistory;
}

std::string Exploit::getTypeName() const {
    switch (type) {
        case ExploitType::BUFFER_OVERFLOW: return "Buffer Overflow";
        case ExploitType::SQL_INJECTION: return "SQL Injection";
        case ExploitType::XSS: return "Cross-Site Scripting";
        case ExploitType::CSRF: return "CSRF";
        case ExploitType::PRIVILEGE_ESCALATION: return "Privilege Escalation";
        case ExploitType::DENIAL_OF_SERVICE: return "Denial of Service";
        case ExploitType::MAN_IN_THE_MIDDLE: return "Man in the Middle";
        case ExploitType::ZERO_DAY: return "Zero Day";
        default: return "Unknown";
    }
}

std::string Exploit::getComplexityName() const {
    switch (complexity) {
        case ExploitComplexity::LOW: return "Low";
        case ExploitComplexity::MEDIUM: return "Medium";
        case ExploitComplexity::HIGH: return "High";
        case ExploitComplexity::CRITICAL: return "Critical";
        default: return "Unknown";
    }
}

void Exploit::setSuccessRate(float rate) {
    if (rate >= 0.0f && rate <= 1.0f) {
        successRate = rate;
    }
}

void Exploit::addExecutionRecord(const std::string& target, bool success, 
                                const std::string& details, const std::vector<std::string>& params) {
    executionHistory.push_back({target, success, details, params});
}

std::string Exploit::toJson() const {
    std::ostringstream json;
    json << "{";
    json << "\"id\":" << id << ",";
    json << "\"name\":\"" << name << "\",";
    json << "\"description\":\"" << description << "\",";
    json << "\"type\":\"" << getTypeName() << "\",";
    json << "\"complexity\":\"" << getComplexityName() << "\",";
    json << "\"successRate\":" << successRate << ",";
    json << "\"isActive\":" << (isActive ? "true" : "false");
    json << "}";
    return json.str();
}

ExploitManager::ExploitManager() {
    loadDefaultExploits();
}

ExploitManager::~ExploitManager() {
}

void ExploitManager::addExploit(const Exploit& exploit) {
    exploits.push_back(exploit);
    std::cout << "Added exploit: " << exploit.getName() << std::endl;
}

void ExploitManager::removeExploit(int id) {
    exploits.erase(
        std::remove_if(exploits.begin(), exploits.end(),
                      [id](const Exploit& e) { return e.getId() == id; }),
        exploits.end()
    );
}

Exploit* ExploitManager::getExploit(int id) {
    for (auto& exploit : exploits) {
        if (exploit.getId() == id) {
            return &exploit;
        }
    }
    return nullptr;
}

const std::vector<Exploit>& ExploitManager::getAllExploits() const {
    return exploits;
}

std::vector<Exploit> ExploitManager::getExploitsByType(ExploitType type) {
    std::vector<Exploit> filtered;
    for (const auto& exploit : exploits) {
        if (exploit.getType() == type) {
            filtered.push_back(exploit);
        }
    }
    return filtered;
}

std::vector<Exploit> ExploitManager::getExploitsByComplexity(ExploitComplexity complexity) {
    std::vector<Exploit> filtered;
    for (const auto& exploit : exploits) {
        if (exploit.getComplexity() == complexity) {
            filtered.push_back(exploit);
        }
    }
    return filtered;
}

void ExploitManager::loadDefaultExploits() {
    // Add some default exploits
    addExploit(Exploit(1, "Heartbleed", "OpenSSL Heartbleed vulnerability", 
                      ExploitType::BUFFER_OVERFLOW, 0.7f, ExploitComplexity::MEDIUM));
    addExploit(Exploit(2, "SQLMap", "Automated SQL injection tool", 
                      ExploitType::SQL_INJECTION, 0.6f, ExploitComplexity::LOW));
    addExploit(Exploit(3, "XSS Scanner", "Cross-site scripting vulnerability scanner", 
                      ExploitType::XSS, 0.5f, ExploitComplexity::LOW));
    addExploit(Exploit(4, "Dirty COW", "Linux privilege escalation exploit", 
                      ExploitType::PRIVILEGE_ESCALATION, 0.8f, ExploitComplexity::HIGH));
    addExploit(Exploit(5, "EternalBlue", "SMB vulnerability exploit", 
                      ExploitType::BUFFER_OVERFLOW, 0.9f, ExploitComplexity::CRITICAL));
    addExploit(Exploit(6, "Slowloris", "HTTP DoS attack", 
                      ExploitType::DENIAL_OF_SERVICE, 0.4f, ExploitComplexity::MEDIUM));
}

void ExploitManager::saveToFile(const std::string& filename) {
    std::ofstream file(filename);
    if (file.is_open()) {
        file << "[\n";
        for (size_t i = 0; i < exploits.size(); ++i) {
            file << exploits[i].toJson();
            if (i < exploits.size() - 1) file << ",";
            file << "\n";
        }
        file << "]\n";
        file.close();
        std::cout << "Exploits saved to " << filename << std::endl;
    }
}

void ExploitManager::loadFromFile(const std::string& filename) {
    // Implementation for loading exploits from file
    std::cout << "Loading exploits from " << filename << std::endl;
}
