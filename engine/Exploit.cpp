#include "Exploit.h"
#include <algorithm>
#include <thread>

// Base Exploit class implementation
Exploit::Exploit(std::string name, std::string description, ExploitType type, int difficulty, double successProb)
    : name(name), description(description), type(type), difficulty(difficulty), successProbability(successProb), targetPort(0) {
}

bool Exploit::requiresService(std::string service) const {
    return targetService == service;
}

bool Exploit::requiresPort(int port) const {
    return targetPort == port;
}

void Exploit::addRequiredTool(std::string tool) {
    requiredTools.push_back(tool);
}

// BruteForceExploit implementation
BruteForceExploit::BruteForceExploit() 
    : Exploit("Brute Force Attack", "Attempt to guess user passwords", BRUTE_FORCE, 3, 0.4), maxAttempts(100) {
    
    // Add common passwords
    passwordList = {
        "password", "123456", "admin", "root", "user", "pass", "password123",
        "admin123", "root123", "user123", "test", "guest", "welcome",
        "changeme", "secret", "qwerty", "letmein", "monkey", "dragon"
    };
    
    // Add common usernames
    usernameList = {
        "admin", "root", "user", "administrator", "guest", "test", "demo",
        "operator", "manager", "support", "helpdesk", "service"
    };
}

bool BruteForceExploit::canExploit(Node& target) {
    // Can exploit if target has user accounts
    return !target.users.empty();
}

ExploitResult BruteForceExploit::execute(Node& target) {
    ExploitResult result;
    auto startTime = std::chrono::high_resolution_clock::now();
    
    result.message = "Attempting brute force attack on " + target.ip;
    
    // Simulate attack attempts
    int attempts = 0;
    bool success = false;
    std::string compromisedUser = "";
    
    for (const std::string& username : usernameList) {
        if (attempts >= maxAttempts) break;
        
        for (const std::string& password : passwordList) {
            if (attempts >= maxAttempts) break;
            
            attempts++;
            
            // Simulate realistic timing
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            
            if (target.authenticateUser(username, password)) {
                success = true;
                compromisedUser = username;
                result.usersCompromised.push_back(username);
                break;
            }
        }
        
        if (success) break;
    }
    
    auto endTime = std::chrono::high_resolution_clock::now();
    result.timeTaken = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    if (success) {
        result.success = true;
        result.accessLevel = USER_ACCESS;
        result.message = "Successfully compromised user: " + compromisedUser;
        
        // Mark target as exploited
        target.markCompromised();
    } else {
        result.success = false;
        result.accessLevel = NO_ACCESS;
        result.errorMessage = "Failed to guess any valid credentials after " + std::to_string(attempts) + " attempts";
    }
    
    return result;
}

void BruteForceExploit::addPassword(std::string password) {
    passwordList.push_back(password);
}

void BruteForceExploit::addUsername(std::string username) {
    usernameList.push_back(username);
}

void BruteForceExploit::setMaxAttempts(int attempts) {
    maxAttempts = attempts;
}

// ServiceExploit implementation
ServiceExploit::ServiceExploit(std::string service, std::string vulnType)
    : Exploit("Service Exploit", "Exploit service-specific vulnerabilities", SERVICE_EXPLOIT, 5, 0.6),
      vulnerabilityType(vulnType), targetService(service) {
    
    // Initialize service vulnerabilities
    serviceVulnerabilities["SSH"] = 0.3;
    serviceVulnerabilities["FTP"] = 0.7;
    serviceVulnerabilities["HTTP"] = 0.5;
    serviceVulnerabilities["HTTPS"] = 0.4;
    serviceVulnerabilities["RDP"] = 0.6;
    serviceVulnerabilities["SMB"] = 0.8;
    serviceVulnerabilities["Telnet"] = 0.9;
}

bool ServiceExploit::canExploit(Node& target) {
    // Check if target has the required service running
    for (const Service& service : target.services) {
        if (service.serviceName == targetService && service.isRunning) {
            return true;
        }
    }
    return false;
}

ExploitResult ServiceExploit::execute(Node& target) {
    ExploitResult result;
    auto startTime = std::chrono::high_resolution_clock::now();
    
    result.message = "Attempting " + vulnerabilityType + " exploit on " + targetService + " service";
    
    // Get vulnerability probability for this service
    double vulnProb = 0.5; // Default
    if (serviceVulnerabilities.find(targetService) != serviceVulnerabilities.end()) {
        vulnProb = serviceVulnerabilities[targetService];
    }
    
    // Simulate exploit attempt
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);
    
    bool success = dis(gen) < vulnProb;
    
    // Simulate realistic timing
    std::this_thread::sleep_for(std::chrono::milliseconds(500));
    
    auto endTime = std::chrono::high_resolution_clock::now();
    result.timeTaken = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    if (success) {
        result.success = true;
        result.accessLevel = USER_ACCESS;
        result.message = "Successfully exploited " + targetService + " service";
        
        // Add some files that might be accessed
        if (targetService == "FTP") {
            result.filesAccessed.push_back("/var/ftp/pub/");
            result.filesAccessed.push_back("/home/ftp/");
        } else if (targetService == "HTTP") {
            result.filesAccessed.push_back("/var/www/html/");
            result.filesAccessed.push_back("/etc/apache2/");
        }
        
        target.markCompromised();
    } else {
        result.success = false;
        result.accessLevel = NO_ACCESS;
        result.errorMessage = "Failed to exploit " + targetService + " service";
    }
    
    return result;
}

void ServiceExploit::addServiceVulnerability(std::string service, double probability) {
    serviceVulnerabilities[service] = probability;
}

// BufferOverflowExploit implementation
BufferOverflowExploit::BufferOverflowExploit()
    : Exploit("Buffer Overflow", "Exploit buffer overflow vulnerabilities", BUFFER_OVERFLOW, 8, 0.3),
      payload("A" * 1000), bufferSize(1024) {
}

bool BufferOverflowExploit::canExploit(Node& target) {
    // Check if target has services that might be vulnerable to buffer overflow
    for (const Service& service : target.services) {
        if (service.serviceName == "FTP" || service.serviceName == "HTTP" || 
            service.serviceName == "SMTP" || service.serviceName == "POP3") {
            return true;
        }
    }
    return false;
}

ExploitResult BufferOverflowExploit::execute(Node& target) {
    ExploitResult result;
    auto startTime = std::chrono::high_resolution_clock::now();
    
    result.message = "Attempting buffer overflow exploit";
    
    // Simulate buffer overflow attempt
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);
    
    bool success = dis(gen) < successProbability;
    
    // Simulate realistic timing
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    
    auto endTime = std::chrono::high_resolution_clock::now();
    result.timeTaken = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    if (success) {
        result.success = true;
        result.accessLevel = ROOT_ACCESS;
        result.message = "Buffer overflow successful - gained root access";
        target.markCompromised();
    } else {
        result.success = false;
        result.accessLevel = NO_ACCESS;
        result.errorMessage = "Buffer overflow failed - service may be patched";
    }
    
    return result;
}

void BufferOverflowExploit::setPayload(std::string payload) {
    this->payload = payload;
}

void BufferOverflowExploit::setBufferSize(int size) {
    bufferSize = size;
}

// PrivilegeEscalationExploit implementation
PrivilegeEscalationExploit::PrivilegeEscalationExploit()
    : Exploit("Privilege Escalation", "Attempt to gain higher privileges", PRIVILEGE_ESCALATION, 7, 0.4) {
    
    escalationMethods = {
        "sudo exploit", "kernel exploit", "service misconfiguration",
        "weak file permissions", "environment variable manipulation"
    };
}

bool PrivilegeEscalationExploit::canExploit(Node& target) {
    // Can attempt privilege escalation if we have some access
    return target.isCompromised();
}

ExploitResult PrivilegeEscalationExploit::execute(Node& target) {
    ExploitResult result;
    auto startTime = std::chrono::high_resolution_clock::now();
    
    result.message = "Attempting privilege escalation";
    
    // Simulate privilege escalation attempt
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(0.0, 1.0);
    
    bool success = dis(gen) < successProbability;
    
    // Simulate realistic timing
    std::this_thread::sleep_for(std::chrono::milliseconds(800));
    
    auto endTime = std::chrono::high_resolution_clock::now();
    result.timeTaken = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    if (success) {
        result.success = true;
        result.accessLevel = ROOT_ACCESS;
        result.message = "Privilege escalation successful - gained root access";
        
        // Access system files
        result.filesAccessed.push_back("/etc/passwd");
        result.filesAccessed.push_back("/etc/shadow");
        result.filesAccessed.push_back("/root/");
    } else {
        result.success = false;
        result.accessLevel = USER_ACCESS;
        result.errorMessage = "Privilege escalation failed";
    }
    
    return result;
}

void PrivilegeEscalationExploit::addEscalationMethod(std::string method) {
    escalationMethods.push_back(method);
}

// ExploitChain implementation
ExploitChain::ExploitChain(std::string name) : name(name), chainSuccessProbability(1.0) {
}

ExploitChain::~ExploitChain() {
    // Don't delete exploits as they're managed by ExploitDatabase
}

void ExploitChain::addExploit(Exploit* exploit) {
    exploits.push_back(exploit);
    // Recalculate chain success probability
    chainSuccessProbability *= exploit->getSuccessProbability();
}

ExploitResult ExploitChain::executeChain(Node& target) {
    ExploitResult result;
    result.message = "Executing exploit chain: " + name;
    
    for (Exploit* exploit : exploits) {
        if (!exploit->canExploit(target)) {
            result.success = false;
            result.errorMessage = "Exploit " + exploit->getName() + " cannot be executed on target";
            return result;
        }
        
        ExploitResult exploitResult = exploit->execute(target);
        if (!exploitResult.success) {
            result.success = false;
            result.errorMessage = "Chain failed at exploit: " + exploit->getName() + " - " + exploitResult.errorMessage;
            return result;
        }
        
        // Update result with successful exploit
        result.accessLevel = std::max(result.accessLevel, exploitResult.accessLevel);
        result.filesAccessed.insert(result.filesAccessed.end(), exploitResult.filesAccessed.begin(), exploitResult.filesAccessed.end());
        result.usersCompromised.insert(result.usersCompromised.end(), exploitResult.usersCompromised.begin(), exploitResult.usersCompromised.end());
        result.timeTaken += exploitResult.timeTaken;
    }
    
    result.success = true;
    result.message = "Exploit chain completed successfully";
    return result;
}

double ExploitChain::getChainSuccessProbability() const {
    return chainSuccessProbability;
}

// ExploitDatabase implementation
ExploitDatabase::ExploitDatabase() {
    loadDefaultExploits();
}

ExploitDatabase::~ExploitDatabase() {
    clearExploits();
}

void ExploitDatabase::addExploit(Exploit* exploit) {
    exploits.push_back(exploit);
    exploitsByType[exploit->getType()].push_back(exploit);
    exploitsByService[exploit->getTargetService()].push_back(exploit);
}

std::vector<Exploit*> ExploitDatabase::getExploitsForNode(Node& target) {
    std::vector<Exploit*> applicableExploits;
    
    for (Exploit* exploit : exploits) {
        if (exploit->canExploit(target)) {
            applicableExploits.push_back(exploit);
        }
    }
    
    return applicableExploits;
}

std::vector<Exploit*> ExploitDatabase::getExploitsForService(std::string service) {
    if (exploitsByService.find(service) != exploitsByService.end()) {
        return exploitsByService[service];
    }
    return std::vector<Exploit*>();
}

std::vector<Exploit*> ExploitDatabase::getExploitsByType(ExploitType type) {
    if (exploitsByType.find(type) != exploitsByType.end()) {
        return exploitsByType[type];
    }
    return std::vector<Exploit*>();
}

std::vector<Exploit*> ExploitDatabase::getAllExploits() const {
    return exploits;
}

Exploit* ExploitDatabase::findExploitByName(std::string name) {
    for (Exploit* exploit : exploits) {
        if (exploit->getName() == name) {
            return exploit;
        }
    }
    return nullptr;
}

void ExploitDatabase::loadDefaultExploits() {
    // Add brute force exploits
    addExploit(new BruteForceExploit());
    
    // Add service exploits
    addExploit(new ServiceExploit("SSH", "weak_configuration"));
    addExploit(new ServiceExploit("FTP", "anonymous_access"));
    addExploit(new ServiceExploit("HTTP", "directory_traversal"));
    addExploit(new ServiceExploit("RDP", "weak_authentication"));
    addExploit(new ServiceExploit("SMB", "null_session"));
    addExploit(new ServiceExploit("Telnet", "cleartext_authentication"));
    
    // Add buffer overflow exploits
    addExploit(new BufferOverflowExploit());
    
    // Add privilege escalation exploits
    addExploit(new PrivilegeEscalationExploit());
}

void ExploitDatabase::clearExploits() {
    for (Exploit* exploit : exploits) {
        delete exploit;
    }
    exploits.clear();
    exploitsByType.clear();
    exploitsByService.clear();
}
