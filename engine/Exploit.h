#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <deque>
#include <list>
#include <random>
#include <chrono>
#include "Node.h"

enum ExploitType {
    BRUTE_FORCE,
    BUFFER_OVERFLOW,
    SERVICE_EXPLOIT,
    PRIVILEGE_ESCALATION,
    SOCIAL_ENGINEERING,
    UNKNOWN
};

enum AccessLevel {
    NO_ACCESS,
    USER_ACCESS,
    ADMIN_ACCESS,
    ROOT_ACCESS
};

struct ExploitResult {
    bool success;
    AccessLevel accessLevel;
    std::string message;
    std::vector<std::string> filesAccessed;
    std::vector<std::string> usersCompromised;
    int timeTaken; // milliseconds
    std::string errorMessage;
    
    ExploitResult() : success(false), accessLevel(NO_ACCESS), timeTaken(0) {}
};

// Forward declaration
class Node;

// Base Exploit class
class Exploit {
protected:
    std::string name;
    std::string description;
    ExploitType type;
    int difficulty; // 1-10 scale
    double successProbability;
    std::string targetService;
    int targetPort;
    std::vector<std::string> requiredTools;
    
public:
    Exploit(std::string name, std::string description, ExploitType type, int difficulty, double successProb);
    virtual ~Exploit() = default;
    
    // Virtual methods that must be implemented by derived classes
    virtual bool canExploit(Node& target) = 0;
    virtual ExploitResult execute(Node& target) = 0;
    
    // Getters
    std::string getName() const { return name; }
    std::string getDescription() const { return description; }
    ExploitType getType() const { return type; }
    int getDifficulty() const { return difficulty; }
    double getSuccessProbability() const { return successProbability; }
    std::string getTargetService() const { return targetService; }
    int getTargetPort() const { return targetPort; }
    
    // Utility methods
    bool requiresService(std::string service) const;
    bool requiresPort(int port) const;
    void addRequiredTool(std::string tool);
};

// Brute Force Exploit
class BruteForceExploit : public Exploit {
private:
    std::vector<std::string> passwordList;
    std::vector<std::string> usernameList;
    int maxAttempts;
    
public:
    BruteForceExploit();
    ~BruteForceExploit() = default;
    
    bool canExploit(Node& target) override;
    ExploitResult execute(Node& target) override;
    
    void addPassword(std::string password);
    void addUsername(std::string username);
    void setMaxAttempts(int attempts);
};

// Service Exploit
class ServiceExploit : public Exploit {
private:
    std::string vulnerabilityType;
    std::map<std::string, double> serviceVulnerabilities;
    
public:
    ServiceExploit(std::string service, std::string vulnType);
    ~ServiceExploit() = default;
    
    bool canExploit(Node& target) override;
    ExploitResult execute(Node& target) override;
    
    void addServiceVulnerability(std::string service, double probability);
};

// Buffer Overflow Exploit
class BufferOverflowExploit : public Exploit {
private:
    std::string payload;
    int bufferSize;
    
public:
    BufferOverflowExploit();
    ~BufferOverflowExploit() = default;
    
    bool canExploit(Node& target) override;
    ExploitResult execute(Node& target) override;
    
    void setPayload(std::string payload);
    void setBufferSize(int size);
};

// Privilege Escalation Exploit
class PrivilegeEscalationExploit : public Exploit {
private:
    std::vector<std::string> escalationMethods;
    
public:
    PrivilegeEscalationExploit();
    ~PrivilegeEscalationExploit() = default;
    
    bool canExploit(Node& target) override;
    ExploitResult execute(Node& target) override;
    
    void addEscalationMethod(std::string method);
};

// Exploit Chain for chaining multiple exploits
class ExploitChain {
private:
    std::vector<Exploit*> exploits;
    std::string name;
    double chainSuccessProbability;
    
public:
    ExploitChain(std::string name);
    ~ExploitChain();
    
    void addExploit(Exploit* exploit);
    ExploitResult executeChain(Node& target);
    double getChainSuccessProbability() const;
    std::string getName() const { return name; }
    int getExploitCount() const { return exploits.size(); }
};

// Exploit Database to manage all exploits
class ExploitDatabase {
private:
    std::vector<Exploit*> exploits;
    std::map<ExploitType, std::vector<Exploit*>> exploitsByType;
    std::map<std::string, std::vector<Exploit*>> exploitsByService;
    
public:
    ExploitDatabase();
    ~ExploitDatabase();
    
    void addExploit(Exploit* exploit);
    std::vector<Exploit*> getExploitsForNode(Node& target);
    std::vector<Exploit*> getExploitsForService(std::string service);
    std::vector<Exploit*> getExploitsByType(ExploitType type);
    std::vector<Exploit*> getAllExploits() const;
    void loadDefaultExploits();
    void clearExploits();
    
    // Utility methods
    Exploit* findExploitByName(std::string name);
    int getExploitCount() const { return exploits.size(); }
};

